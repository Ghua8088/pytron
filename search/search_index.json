{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pytron","text":"<p>Pytron is a modern framework for building desktop applications using Python for the backend and web technologies (React, Vite) for the frontend. It combines the power of Python's ecosystem with the rich user interfaces of the web.</p> <ul> <li>Get Started </li> <li>View API Reference</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-Safe Bridge: Automatically generate TypeScript definitions (<code>.d.ts</code>) from your Python code.</li> <li>Reactive State: Synchronize state seamlessly between Python and JavaScript.</li> <li>Advanced Serialization: Built-in support for Pydantic models, PIL Images, UUIDs, and more.</li> <li>System Integration: Native file dialogs, notifications, and shortcuts.</li> <li>Developer Experience: Hot-reloading, automatic virtual environment management, and easy packaging.</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>Node.js &amp; npm (for frontend development)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li> <p>Install Pytron:     <pre><code>pip install pytron-kit\n</code></pre></p> </li> <li> <p>Initialize a New Project:     This command scaffolds a new project, creates a virtual environment, installs dependencies, and sets up a frontend.     <pre><code># Default (React + Vite)\npytron init my_app\n\n# Using a specific template (vue, svelte, next, etc.)\npytron init my_app --template next\n</code></pre>     Supported templates: <code>react</code> (default), <code>vue</code>, <code>svelte</code>, <code>next</code> (Next.js), <code>vanilla</code>, <code>preact</code>, <code>lit</code>, <code>solid</code>, <code>qwik</code>.</p> </li> <li> <p>Run the App:     Start the app in development mode (hot-reloading enabled).</p> <ul> <li>Windows: <code>run.bat</code></li> <li>Linux/Mac: <code>./run.sh</code></li> </ul> <p>Or manually: <pre><code>pytron run --dev\n</code></pre></p> </li> </ol>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#1-exposing-python-functions","title":"1. Exposing Python Functions","text":"<p>Use the <code>@app.expose</code> decorator to make Python functions available to the frontend.</p> <pre><code>from pytron import App\nfrom pydantic import BaseModel\n\napp = App()\n\nclass User(BaseModel):\n    name: str\n    age: int\n\n@app.expose\ndef get_user(user_id: int) -&gt; User:\n    return User(name=\"Alice\", age=30)\n\napp.generate_types() # Generates frontend/src/pytron.d.ts\napp.run()\n</code></pre>"},{"location":"#2-calling-from-frontend","title":"2. Calling from Frontend","text":"<p>Import the client and call your functions with full TypeScript support.</p> <pre><code>import pytron from 'pytron-client';\n\nasync function loadUser() {\n    const user = await pytron.get_user(1);\n    console.log(user.name); // Typed as string\n}\n</code></pre>"},{"location":"#3-reactive-state","title":"3. Reactive State","text":"<p>Sync data automatically.</p> <p>Python: <pre><code>app.state.counter = 0\n</code></pre></p> <p>JavaScript: <pre><code>console.log(pytron.state.counter); // 0\n\n// Listen for changes\npytron.on('pytron:state-update', (change) =&gt; {\n    console.log(change.key, change.value);\n});\n</code></pre></p>"},{"location":"#4-window-management","title":"4. Window Management","text":"<p>Control the window directly from JS.</p> <pre><code>pytron.minimize();\npytron.toggle_fullscreen();\npytron.close();\n</code></pre>"},{"location":"#configuration-settingsjson","title":"Configuration (settings.json)","text":"<p>Pytron uses a <code>settings.json</code> file in your project root to manage application configuration. This keeps your code clean and separates config from logic.</p> <p>Example <code>settings.json</code>: <pre><code>{\n    \"title\": \"My Awesome App\",\n    \"pytron_version\": \"0.1.5\",\n    \"frontend_framework\": \"react\",\n    \"width\": 1024,\n    \"height\": 768,\n    \"resizable\": true,\n    \"frameless\": false,\n    \"easy_drag\": true,\n    \"url\": \"frontend/dist/index.html\",\n    \"icon\": \"assets/icon.ico\",\n    \"version\": \"1.0.0\"\n}\n</code></pre></p> <ul> <li>title: The window title and the name of your packaged executable.</li> <li>pytron_version: The version of Pytron used to create the project (used for compatibility checks).</li> <li>frontend_framework: The framework used (e.g., \"react\", \"next\").</li> <li>icon: Path to your application icon (relative to project root). Supports <code>.ico</code> (preferred) or <code>.png</code>.</li> <li>url: Entry point for the frontend (usually the built <code>index.html</code>).</li> <li>width/height: Initial window dimensions.</li> </ul>"},{"location":"#packaging","title":"Packaging","text":"<p>Distribute your app as a standalone executable. Pytron automatically reads your <code>settings.json</code> to determine the app name, version, and icon.</p> <ol> <li> <p>Build:     <pre><code>pytron package\n</code></pre>     This uses PyInstaller to bundle your app. It will:</p> <ul> <li>Use the <code>title</code> from <code>settings.json</code> for the executable name.</li> <li>Use the <code>icon</code> from <code>settings.json</code> for the app icon.</li> <li>Automatically exclude <code>node_modules</code>.</li> <li>Include your <code>settings.json</code> and frontend assets.</li> </ul> </li> <li> <p>Create Installer (NSIS):     <pre><code>pytron package --installer\n</code></pre></p> </li> </ol>"},{"location":"#cli-reference","title":"CLI Reference","text":"<ul> <li><code>pytron init &lt;name&gt; [--template &lt;name&gt;]</code>: Create a new project.<ul> <li><code>--template</code>: Frontend framework to use (default: <code>react</code>). Supports <code>next</code>, <code>vue</code>, <code>svelte</code>, etc.</li> </ul> </li> <li><code>pytron run [--dev]</code>: Run the application.</li> <li><code>pytron package [--installer]</code>: Build for distribution (uses <code>settings.json</code>).</li> <li><code>pytron info</code>: Show environment and project details.</li> <li><code>pytron build-frontend &lt;folder&gt;</code>: Build the frontend app.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#application","title":"Application","text":""},{"location":"api/#pytron.application.App","title":"<code>pytron.application.App</code>","text":"Source code in <code>pytron\\application.py</code> <pre><code>class App:\n    def __init__(self, config_file='settings.json'):\n        self.windows = []\n        self.is_running = False\n        self.config = {}\n        self._exposed_functions = {} # Global functions for all windows\n        self._exposed_ts_defs = {} # Store generated TS definitions\n        self._pydantic_models = {} # Store pydantic models to generate interfaces for\n        self.shortcuts = {} # Global shortcuts\n        self.state = ReactiveState(self) # Magic state object\n\n        # Load config\n        # Try to find settings.json\n        # 1. Using get_resource_path (handles PyInstaller)\n        path = get_resource_path(config_file)\n        if not os.path.exists(path):\n            # 2. Try relative to the current working directory (useful during dev if running from root)\n            path = os.path.abspath(config_file)\n\n        if os.path.exists(path):\n            try:\n                import json\n                with open(path, 'r') as f:\n                    self.config = json.load(f)\n                # print(f\"[Pytron] Loaded settings from {path}\")\n\n                # Check version compatibility\n                config_version = self.config.get('pytron_version')\n                if config_version:\n                    try:\n                        from . import __version__\n                        if config_version != __version__:\n                            print(f\"[Pytron] Warning: Project settings version ({config_version}) does not match installed Pytron version ({__version__}).\")\n                    except ImportError:\n                        pass\n            except Exception as e:\n                print(f\"[Pytron] Failed to load settings: {e}\")\n\n    def create_window(self, title=None, url=None, html=None, js_api=None, width=None, height=None, **kwargs):\n        # Merge config with arguments. Arguments take precedence.\n\n        # Helper to get value from arg, then config, then default\n        def get_val(arg, key, default):\n            if arg is not None:\n                return arg\n            return self.config.get(key, default)\n\n        # Resolve URL\n        final_url = url\n        if final_url is None:\n            final_url = self.config.get('url')\n            # If we got a URL from config, check if it needs path resolution\n            if final_url and not final_url.startswith('http') and not final_url.startswith('file://'):\n                final_url = get_resource_path(final_url)\n                if not os.path.exists(final_url):\n                    # Fallback check relative to cwd\n                    cwd_path = os.path.abspath(self.config.get('url'))\n                    if os.path.exists(cwd_path):\n                        final_url = cwd_path\n\n        # Construct window with resolved values\n        # Note: We pass defaults here that match the original Window.__init__ defaults if not in config\n        window = Window(\n            title=get_val(title, 'title', 'Pytron App'),\n            url=final_url,\n            html=get_val(html, 'html', None),\n            js_api=js_api,\n            width=get_val(width, 'width', 800),\n            height=get_val(height, 'height', 600),\n            resizable=get_val(kwargs.get('resizable'), 'resizable', True),\n            fullscreen=get_val(kwargs.get('fullscreen'), 'fullscreen', False),\n            min_size=get_val(kwargs.get('min_size'), 'min_size', (200, 100)),\n            hidden=get_val(kwargs.get('hidden'), 'hidden', False),\n            frameless=get_val(kwargs.get('frameless'), 'frameless', False),\n            easy_drag=get_val(kwargs.get('easy_drag'), 'easy_drag', True),\n            **{k: v for k, v in kwargs.items() if k not in ['resizable', 'fullscreen', 'min_size', 'hidden', 'frameless', 'easy_drag']}\n        )\n        # Link app reference to window so it can access global exposed functions\n        window._app_ref = self\n\n        self.windows.append(window)\n\n        # If the app is already running, create the window immediately.\n        # Otherwise, wait until run() is called to allow for configuration (e.g. expose).\n        if self.is_running:\n            window.create()\n\n        return window\n\n    def run(self, debug=False, menu=None, **kwargs):\n        self.is_running = True\n        # Create any pending windows\n        for window in self.windows:\n            if window._window is None:\n                window.create()\n\n        # Ensure we have a writable storage_path for WebView2 cache\n        # Default behavior tries to write to executable dir, which fails in Program Files\n        if 'storage_path' not in kwargs:\n            title = self.config.get('title', 'Pytron App')\n            # Sanitize title for folder name\n            safe_title = \"\".join(c if c.isalnum() or c in ('-', '_') else '_' for c in title).strip('_')\n\n            if sys.platform == 'win32':\n                base_path = os.environ.get('LOCALAPPDATA', os.path.expanduser('~'))\n            else:\n                base_path = os.path.expanduser('~/.config')\n\n            storage_path = os.path.join(base_path, safe_title)\n            kwargs['storage_path'] = storage_path\n\n            # Ensure directory exists (pywebview might do this, but good to be safe)\n            try:\n                os.makedirs(storage_path, exist_ok=True)\n            except Exception:\n                pass # Let pywebview handle or fail if it can't write\n\n        # pywebview.start() is a blocking call that runs the GUI loop\n        # Menu is passed to start() in pywebview\n        webview.start(debug=debug, menu=menu, http_server=False,**kwargs)\n        self.is_running = False\n\n    def quit(self):\n        for window in self.windows:\n            window.destroy()\n\n    def _python_type_to_ts(self, py_type):\n        if py_type == str: return \"string\"\n        if py_type == int: return \"number\"\n        if py_type == float: return \"number\"\n        if py_type == bool: return \"boolean\"\n        if py_type == type(None): return \"void\"\n        if py_type == list: return \"any[]\"\n        if py_type == dict: return \"Record&lt;string, any&gt;\"\n\n        # Handle Pydantic Models\n        if pydantic and isinstance(py_type, type) and issubclass(py_type, pydantic.BaseModel):\n            model_name = py_type.__name__\n            self._pydantic_models[model_name] = py_type\n            return model_name\n\n        # Handle typing module\n        origin = getattr(py_type, '__origin__', None)\n        args = getattr(py_type, '__args__', ())\n\n        if origin is list or origin is typing.List:\n            if args:\n                return f\"{self._python_type_to_ts(args[0])}[]\"\n            return \"any[]\"\n\n        if origin is dict or origin is typing.Dict:\n            if args and len(args) == 2:\n                k = self._python_type_to_ts(args[0])\n                v = self._python_type_to_ts(args[1])\n                if k == \"number\":\n                    return f\"Record&lt;number, {v}&gt;\"\n                return f\"Record&lt;string, {v}&gt;\"\n            return \"Record&lt;string, any&gt;\"\n\n        if origin is typing.Union:\n            non_none = [t for t in args if t != type(None)]\n            if len(non_none) == len(args):\n                return \" | \".join([self._python_type_to_ts(t) for t in args])\n            else:\n                if len(non_none) == 1:\n                    return f\"{self._python_type_to_ts(non_none[0])} | null\"\n                return \" | \".join([self._python_type_to_ts(t) for t in non_none]) + \" | null\"\n\n        return \"any\"\n\n    def _generate_pydantic_interface(self, model_name, model_cls):\n        lines = [f\"  export interface {model_name} {{\"]\n\n        # Pydantic v1 vs v2\n        fields = {}\n        if hasattr(model_cls, 'model_fields'): # v2\n            fields = model_cls.model_fields\n        elif hasattr(model_cls, '__fields__'): # v1\n            fields = model_cls.__fields__\n\n        for field_name, field in fields.items():\n            # Get type annotation\n            if hasattr(field, 'annotation'): # v2\n                py_type = field.annotation\n            elif hasattr(field, 'type_'): # v1\n                py_type = field.type_\n            else:\n                py_type = typing.Any\n\n            ts_type = self._python_type_to_ts(py_type)\n\n            # Check if optional\n            is_optional = False\n            if hasattr(field, 'is_required'): # v2\n                 is_optional = not field.is_required()\n            elif hasattr(field, 'required'): # v1\n                 is_optional = not field.required\n\n            suffix = \"?\" if is_optional else \"\"\n            lines.append(f\"    {field_name}{suffix}: {ts_type};\")\n\n        lines.append(\"  }\")\n        return \"\\n\".join(lines)\n\n    def _get_ts_definition(self, name, func):\n        try:\n            sig = inspect.signature(func)\n            params = []\n\n            for param_name, param in sig.parameters.items():\n                if param_name == \"self\": continue\n\n                py_type = param.annotation\n                ts_type = self._python_type_to_ts(py_type)\n                if py_type == inspect.Parameter.empty:\n                    ts_type = \"any\"\n\n                params.append(f\"{param_name}: {ts_type}\")\n\n            param_str = \", \".join(params)\n\n            return_annotation = sig.return_annotation\n            ts_return = self._python_type_to_ts(return_annotation)\n            if return_annotation == inspect.Parameter.empty:\n                ts_return = \"any\"\n\n            lines = []\n            doc = inspect.getdoc(func)\n            if doc:\n                lines.append(\"    /**\")\n                for line in doc.split('\\n'):\n                    lines.append(f\"     * {line}\")\n                lines.append(\"     */\")\n\n            lines.append(f\"    {name}({param_str}): Promise&lt;{ts_return}&gt;;\")\n            return \"\\n\".join(lines)\n\n        except Exception as e:\n            print(f\"[Pytron] Warning: Could not generate types for {name}: {e}\")\n            return f\"    {name}(...args: any[]): Promise&lt;any&gt;;\"\n\n    def expose(self, func=None, name=None):\n        \"\"\"\n        Expose a function to ALL windows created by this App.\n        Can be used as a decorator: @app.expose\n        \"\"\"\n        if func is None:\n            def decorator(f):\n                self.expose(f, name=name)\n                return f\n            return decorator\n\n        if name is None:\n            name = func.__name__\n        self._exposed_functions[name] = func\n        self._exposed_ts_defs[name] = self._get_ts_definition(name, func)\n        return func\n\n    def shortcut(self, key_combo, func=None):\n        \"\"\"\n        Register a global keyboard shortcut for all windows.\n        Example: @app.shortcut('Ctrl+Q')\n        \"\"\"\n        if func is None:\n            def decorator(f):\n                self.shortcut(key_combo, f)\n                return f\n            return decorator\n        self.shortcuts[key_combo] = func\n        return func\n\n    def generate_types(self, output_path=\"frontend/src/pytron.d.ts\"):\n        \"\"\"\n        Generates TypeScript definitions for all exposed functions.\n        \"\"\"\n        ts_lines = [\n            \"// Auto-generated by Pytron. Do not edit manually.\",\n            \"// This file provides type definitions for the Pytron client.\",\n            \"\",\n            \"declare module 'pytron-client' {\",\n        ]\n\n        # 0. Add Pydantic Interfaces\n        # We need to process exposed functions first to populate _pydantic_models\n        # But wait, _exposed_ts_defs are already generated during @expose.\n        # So _pydantic_models should be populated if they were used in signatures.\n        # However, nested models might be missed if we don't recurse properly in _python_type_to_ts.\n        # My current _python_type_to_ts does recurse for List/Dict/Union, so it should find them.\n\n        # We iterate a copy because generating one interface might discover more models (nested)\n        processed_models = set()\n        while True:\n            current_models = set(self._pydantic_models.keys())\n            new_models = current_models - processed_models\n            if not new_models:\n                break\n\n            for model_name in new_models:\n                model_cls = self._pydantic_models[model_name]\n                ts_lines.append(self._generate_pydantic_interface(model_name, model_cls))\n                processed_models.add(model_name)\n\n        ts_lines.append(\"\")\n        ts_lines.append(\"  export interface PytronClient {\")\n        ts_lines.append(\"    /**\")\n        ts_lines.append(\"     * Local state cache synchronized with the backend.\")\n        ts_lines.append(\"     */\")\n        ts_lines.append(\"    state: Record&lt;string, any&gt;;\")\n        ts_lines.append(\"\")\n        ts_lines.append(\"    /**\")\n        ts_lines.append(\"     * Listen for an event sent from the Python backend.\")\n        ts_lines.append(\"     */\")\n        ts_lines.append(\"    on(event: string, callback: (data: any) =&gt; void): void;\")\n        ts_lines.append(\"\")\n        ts_lines.append(\"    /**\")\n        ts_lines.append(\"     * Remove an event listener.\")\n        ts_lines.append(\"     */\")\n        ts_lines.append(\"    off(event: string, callback: (data: any) =&gt; void): void;\")\n        ts_lines.append(\"\")\n        ts_lines.append(\"    /**\")\n        ts_lines.append(\"     * Wait for the backend to be connected.\")\n        ts_lines.append(\"     */\")\n        ts_lines.append(\"    waitForBackend(timeout?: number): Promise&lt;void&gt;;\")\n        ts_lines.append(\"\")\n        ts_lines.append(\"    /**\")\n        ts_lines.append(\"     * Log a message to the Python console.\")\n        ts_lines.append(\"     */\")\n        ts_lines.append(\"    log(message: string): Promise&lt;void&gt;;\")\n        ts_lines.append(\"\")\n\n        # 1. Add User Exposed Functions (pre-calculated in expose)\n        for def_str in self._exposed_ts_defs.values():\n            ts_lines.append(def_str)\n\n        # 2. Add SystemAPI methods\n        system_api = SystemAPI(None)\n        for attr_name in dir(system_api):\n            if not attr_name.startswith('_'):\n                attr = getattr(system_api, attr_name)\n                if callable(attr):\n                    ts_lines.append(self._get_ts_definition(attr_name, attr))\n\n        # 3. Add Window methods\n        # Map exposed name to Window class method name\n        win_map = {\n            'minimize': 'minimize',\n            'maximize': 'maximize',\n            'restore': 'restore',\n            'close': 'destroy',\n            'toggle_fullscreen': 'toggle_fullscreen',\n            'resize': 'resize',\n            'get_size': 'get_size',\n        }\n\n        for exposed_name, method_name in win_map.items():\n            if hasattr(Window, method_name):\n                method = getattr(Window, method_name)\n                ts_lines.append(self._get_ts_definition(exposed_name, method))\n\n        # 4. Add dynamic methods that are not on Window class\n        ts_lines.append(\"    trigger_shortcut(combo: string): Promise&lt;boolean&gt;;\")\n        ts_lines.append(\"    get_registered_shortcuts(): Promise&lt;string[]&gt;;\")\n\n        ts_lines.append(\"  }\")\n        ts_lines.append(\"\")\n        ts_lines.append(\"  const pytron: PytronClient;\")\n        ts_lines.append(\"  export default pytron;\")\n        ts_lines.append(\"}\")\n\n        # Ensure directory exists\n        dirname = os.path.dirname(output_path)\n        if dirname and not os.path.exists(dirname):\n            try:\n                os.makedirs(dirname)\n            except Exception:\n                pass\n\n        try:\n            with open(output_path, \"w\") as f:\n                f.write(\"\\n\".join(ts_lines))\n            print(f\"[Pytron] \u2705 Generated TypeScript definitions at {output_path}\")\n        except Exception as e:\n            print(f\"[Pytron] Failed to write TypeScript definitions: {e}\")\n</code></pre>"},{"location":"api/#pytron.application.App.expose","title":"<code>expose(func=None, name=None)</code>","text":"<p>Expose a function to ALL windows created by this App. Can be used as a decorator: @app.expose</p> Source code in <code>pytron\\application.py</code> <pre><code>def expose(self, func=None, name=None):\n    \"\"\"\n    Expose a function to ALL windows created by this App.\n    Can be used as a decorator: @app.expose\n    \"\"\"\n    if func is None:\n        def decorator(f):\n            self.expose(f, name=name)\n            return f\n        return decorator\n\n    if name is None:\n        name = func.__name__\n    self._exposed_functions[name] = func\n    self._exposed_ts_defs[name] = self._get_ts_definition(name, func)\n    return func\n</code></pre>"},{"location":"api/#pytron.application.App.generate_types","title":"<code>generate_types(output_path='frontend/src/pytron.d.ts')</code>","text":"<p>Generates TypeScript definitions for all exposed functions.</p> Source code in <code>pytron\\application.py</code> <pre><code>def generate_types(self, output_path=\"frontend/src/pytron.d.ts\"):\n    \"\"\"\n    Generates TypeScript definitions for all exposed functions.\n    \"\"\"\n    ts_lines = [\n        \"// Auto-generated by Pytron. Do not edit manually.\",\n        \"// This file provides type definitions for the Pytron client.\",\n        \"\",\n        \"declare module 'pytron-client' {\",\n    ]\n\n    # 0. Add Pydantic Interfaces\n    # We need to process exposed functions first to populate _pydantic_models\n    # But wait, _exposed_ts_defs are already generated during @expose.\n    # So _pydantic_models should be populated if they were used in signatures.\n    # However, nested models might be missed if we don't recurse properly in _python_type_to_ts.\n    # My current _python_type_to_ts does recurse for List/Dict/Union, so it should find them.\n\n    # We iterate a copy because generating one interface might discover more models (nested)\n    processed_models = set()\n    while True:\n        current_models = set(self._pydantic_models.keys())\n        new_models = current_models - processed_models\n        if not new_models:\n            break\n\n        for model_name in new_models:\n            model_cls = self._pydantic_models[model_name]\n            ts_lines.append(self._generate_pydantic_interface(model_name, model_cls))\n            processed_models.add(model_name)\n\n    ts_lines.append(\"\")\n    ts_lines.append(\"  export interface PytronClient {\")\n    ts_lines.append(\"    /**\")\n    ts_lines.append(\"     * Local state cache synchronized with the backend.\")\n    ts_lines.append(\"     */\")\n    ts_lines.append(\"    state: Record&lt;string, any&gt;;\")\n    ts_lines.append(\"\")\n    ts_lines.append(\"    /**\")\n    ts_lines.append(\"     * Listen for an event sent from the Python backend.\")\n    ts_lines.append(\"     */\")\n    ts_lines.append(\"    on(event: string, callback: (data: any) =&gt; void): void;\")\n    ts_lines.append(\"\")\n    ts_lines.append(\"    /**\")\n    ts_lines.append(\"     * Remove an event listener.\")\n    ts_lines.append(\"     */\")\n    ts_lines.append(\"    off(event: string, callback: (data: any) =&gt; void): void;\")\n    ts_lines.append(\"\")\n    ts_lines.append(\"    /**\")\n    ts_lines.append(\"     * Wait for the backend to be connected.\")\n    ts_lines.append(\"     */\")\n    ts_lines.append(\"    waitForBackend(timeout?: number): Promise&lt;void&gt;;\")\n    ts_lines.append(\"\")\n    ts_lines.append(\"    /**\")\n    ts_lines.append(\"     * Log a message to the Python console.\")\n    ts_lines.append(\"     */\")\n    ts_lines.append(\"    log(message: string): Promise&lt;void&gt;;\")\n    ts_lines.append(\"\")\n\n    # 1. Add User Exposed Functions (pre-calculated in expose)\n    for def_str in self._exposed_ts_defs.values():\n        ts_lines.append(def_str)\n\n    # 2. Add SystemAPI methods\n    system_api = SystemAPI(None)\n    for attr_name in dir(system_api):\n        if not attr_name.startswith('_'):\n            attr = getattr(system_api, attr_name)\n            if callable(attr):\n                ts_lines.append(self._get_ts_definition(attr_name, attr))\n\n    # 3. Add Window methods\n    # Map exposed name to Window class method name\n    win_map = {\n        'minimize': 'minimize',\n        'maximize': 'maximize',\n        'restore': 'restore',\n        'close': 'destroy',\n        'toggle_fullscreen': 'toggle_fullscreen',\n        'resize': 'resize',\n        'get_size': 'get_size',\n    }\n\n    for exposed_name, method_name in win_map.items():\n        if hasattr(Window, method_name):\n            method = getattr(Window, method_name)\n            ts_lines.append(self._get_ts_definition(exposed_name, method))\n\n    # 4. Add dynamic methods that are not on Window class\n    ts_lines.append(\"    trigger_shortcut(combo: string): Promise&lt;boolean&gt;;\")\n    ts_lines.append(\"    get_registered_shortcuts(): Promise&lt;string[]&gt;;\")\n\n    ts_lines.append(\"  }\")\n    ts_lines.append(\"\")\n    ts_lines.append(\"  const pytron: PytronClient;\")\n    ts_lines.append(\"  export default pytron;\")\n    ts_lines.append(\"}\")\n\n    # Ensure directory exists\n    dirname = os.path.dirname(output_path)\n    if dirname and not os.path.exists(dirname):\n        try:\n            os.makedirs(dirname)\n        except Exception:\n            pass\n\n    try:\n        with open(output_path, \"w\") as f:\n            f.write(\"\\n\".join(ts_lines))\n        print(f\"[Pytron] \u2705 Generated TypeScript definitions at {output_path}\")\n    except Exception as e:\n        print(f\"[Pytron] Failed to write TypeScript definitions: {e}\")\n</code></pre>"},{"location":"api/#pytron.application.App.shortcut","title":"<code>shortcut(key_combo, func=None)</code>","text":"<p>Register a global keyboard shortcut for all windows. Example: @app.shortcut('Ctrl+Q')</p> Source code in <code>pytron\\application.py</code> <pre><code>def shortcut(self, key_combo, func=None):\n    \"\"\"\n    Register a global keyboard shortcut for all windows.\n    Example: @app.shortcut('Ctrl+Q')\n    \"\"\"\n    if func is None:\n        def decorator(f):\n            self.shortcut(key_combo, f)\n            return f\n        return decorator\n    self.shortcuts[key_combo] = func\n    return func\n</code></pre>"},{"location":"api/#window","title":"Window","text":""},{"location":"api/#pytron.window.Window","title":"<code>pytron.window.Window</code>","text":"Source code in <code>pytron\\window.py</code> <pre><code>class Window:\n    def __init__(self, title, url=None, html=None, js_api=None, width=800, height=600, \n                 resizable=True, fullscreen=False, min_size=(200, 100), hidden=False, \n                 frameless=False, easy_drag=True, on_loaded=None, on_closing=None, \n                 on_closed=None, on_shown=None, on_minimized=None, on_maximized=None, \n                 on_restored=None, on_resized=None, on_moved=None, **kwargs):\n        self.title = title\n        self.url = url\n        self.html = html\n        self.js_api = js_api\n        self.width = width\n        self.height = height\n        self.resizable = resizable\n        self.fullscreen = fullscreen\n        self.min_size = min_size\n        self.hidden = hidden\n        self.frameless = frameless\n        self.easy_drag = easy_drag\n\n        # Events\n        self.on_loaded = on_loaded\n        self.on_closing = on_closing\n        self.on_closed = on_closed\n        self.on_shown = on_shown\n        self.on_minimized = on_minimized\n        self.on_maximized = on_maximized\n        self.on_restored = on_restored\n        self.on_resized = on_resized\n        self.on_moved = on_moved\n\n        self._window = None\n        self._exposed_functions = {}\n        self.shortcuts = {}\n        # Reference to parent App (set by App when window is registered)\n        self._app_ref = None\n\n    def shortcut(self, key_combo, func=None):\n        \"\"\"\n        Register a keyboard shortcut for this window.\n        Example: @window.shortcut('Ctrl+S')\n        \"\"\"\n        if func is None:\n            def decorator(f):\n                self.shortcut(key_combo, f)\n                return f\n            return decorator\n        self.shortcuts[key_combo] = func\n        return func\n\n    def expose(self, func=None, name=None):\n        \"\"\"\n        Expose a Python function to JavaScript. Can be used as a decorator.\n        @window.expose\n        def my_func(): ...\n        \"\"\"\n        if self._window:\n             raise RuntimeError(\"Cannot expose functions after window creation. Call expose() before app.run() or window.create().\")\n\n        # Handle decorator usage: @window.expose or @window.expose(name=\"foo\")\n        if func is None:\n            def decorator(f):\n                self.expose(f, name=name)\n                return f\n            return decorator\n\n        if name is None:\n            name = func.__name__\n        self._exposed_functions[name] = func\n        return func\n\n    def minimize(self):\n        if self._window:\n            self._window.minimize()\n\n    def maximize(self):\n        if self._window:\n            self._window.maximize()\n\n    def restore(self):\n        if self._window:\n            self._window.restore()\n\n    def toggle_fullscreen(self):\n        if self._window:\n            self._window.toggle_fullscreen()\n\n    def resize(self, width, height):\n        if self._window:\n            self._window.resize(width, height)\n\n    def get_size(self):\n        if self._window:\n            return {\"width\": self._window.width, \"height\": self._window.height}\n        return {\"width\": self.width, \"height\": self.height}\n\n    def move(self, x, y):\n        if self._window:\n            self._window.move(x, y)\n\n    def destroy(self):\n        if self._window:\n            try:\n                self._window.destroy()\n            except Exception:\n                pass\n            # Clear the underlying webview window reference\n            self._window = None\n        # Remove from parent App window list if present\n        if getattr(self, '_app_ref', None):\n            try:\n                if hasattr(self._app_ref, 'remove_window'):\n                    try:\n                        self._app_ref.remove_window(self)\n                    except Exception:\n                        # Fallback to direct list removal\n                        try:\n                            self._app_ref.windows.remove(self)\n                        except Exception:\n                            pass\n                else:\n                    try:\n                        self._app_ref.windows.remove(self)\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n\n    @property\n    def on_top(self):\n        if self._window:\n            return self._window.on_top\n\n    @on_top.setter\n    def on_top(self, on_top):\n        if self._window:\n            self._window.on_top = on_top\n\n    def load_url(self, url):\n        if self._window:\n            self._window.load_url(url)\n\n    def load_html(self, content, base_uri=None):\n        if self._window:\n            self._window.load_html(content, base_uri)\n\n    def emit(self, event, data=None):\n        \"\"\"\n        Emit an event to the JavaScript frontend.\n        \"\"\"\n        if self._window:\n            # We use a safe serialization\n            try:\n                # Serialize the payload using our encoder\n                payload = json.dumps(data, cls=PytronJSONEncoder)\n                self._window.evaluate_js(f\"window.__pytron_dispatch('{event}', {payload})\")\n                # Serialize the call arguments (event name and payload string)\n            except Exception as e:\n                print(f\"[Pytron] Failed to emit event '{event}': {e}\")\n\n    def _build_api(self):\n        # Create a dictionary of methods to expose\n        methods = {}\n\n        # Helper wrapper to ensure serialization\n        def create_wrapper(func):\n            # The wrapper will be attached as a method on the dynamic API class.\n            # pywebview will call it as a bound method, so the first argument\n            # will be the api instance. We must accept that parameter but not\n            # forward it to the underlying function `func`.\n            def wrapper(api_self, *args, _func=func, **kwargs):\n                result = _func(*args, **kwargs)\n                # Serialize complex types to simple JSON-able structures\n                return pytron_serialize(result)\n            return wrapper\n\n        # 1. Add existing js_api methods\n        if self.js_api:\n            for attr_name in dir(self.js_api):\n                if not attr_name.startswith('_'):\n                    attr = getattr(self.js_api, attr_name)\n                    if callable(attr):\n                        methods[attr_name] = create_wrapper(attr)\n\n        # 2. Add explicitly exposed functions (Window level)\n        for name, func in self._exposed_functions.items():\n            methods[name] = create_wrapper(func)\n\n        # 2.5 Add Global App exposed functions (App level)\n        if hasattr(self, '_app_ref') and self._app_ref:\n             for name, func in self._app_ref._exposed_functions.items():\n                if name not in methods: # Window specific overrides global\n                    methods[name] = create_wrapper(func)\n\n        # 3. Add window management methods automatically\n        window_methods = {\n            'minimize': self.minimize,\n            'maximize': self.maximize,\n            'restore': self.restore,\n            'close': self.destroy,\n            'toggle_fullscreen': self.toggle_fullscreen,\n            'resize': self.resize,\n            'get_size': self.get_size,\n        }\n\n        for name, func in window_methods.items():\n            if name not in methods:\n                methods[name] = create_wrapper(func)\n\n        # 4. Add System API methods automatically\n        system_api = SystemAPI(self)\n        for attr_name in dir(system_api):\n            if not attr_name.startswith('_'):\n                attr = getattr(system_api, attr_name)\n                if callable(attr):\n                    if attr_name not in methods:\n                        methods[attr_name] = create_wrapper(attr)\n\n        # 5. Add Shortcut Handling\n        def trigger_shortcut(api_self, combo):\n            # Check window shortcuts first\n            if combo in self.shortcuts:\n                self.shortcuts[combo]()\n                return True\n            # Check app shortcuts\n            if hasattr(self, '_app_ref') and self._app_ref and combo in self._app_ref.shortcuts:\n                self._app_ref.shortcuts[combo]()\n                return True\n            return False\n        methods['trigger_shortcut'] = trigger_shortcut\n\n        def get_registered_shortcuts(api_self):\n            keys = list(self.shortcuts.keys())\n            if hasattr(self, '_app_ref') and self._app_ref:\n                keys.extend(self._app_ref.shortcuts.keys())\n            return list(set(keys))\n        methods['get_registered_shortcuts'] = get_registered_shortcuts\n\n        # Create the dynamic class\n        DynamicApi = type('DynamicApi', (object,), methods)\n\n        # Return an instance of this class\n        api_instance = DynamicApi()\n        print(f\"[Pytron] Built API with methods: {list(methods.keys())}\")\n        return api_instance\n\n    def create(self):\n        # Build the final API object\n        final_api = self._build_api()\n\n        # Severe and important changes: Force file:// protocol and disable http_server\n        # 1. Get the absolute path to your index.html\n        # (Make sure this points to the DIST folder, not source)\n        try:\n            # Try to find the main script directory\n            if hasattr(sys.modules['__main__'], '__file__'):\n                main_dir = os.path.dirname(os.path.abspath(sys.modules['__main__'].__file__))\n            else:\n                main_dir = os.getcwd()\n        except Exception:\n            main_dir = os.getcwd()\n\n        dist_path = os.path.join(main_dir, \"frontend\", \"dist\", \"index.html\")\n\n        # Default to provided url\n        target_url = self.url\n        use_http_server = True\n\n        if os.path.exists(dist_path):\n            real_path = os.path.abspath(dist_path)\n            # 2. Use file:// protocol\n            target_url = f\"file://{real_path}\"\n            # 3. Create window with NO server\n            use_http_server = False # &lt;--- THE KILL SWITCH\n\n        self._window = webview.create_window(\n            self.title,\n            url=target_url,\n            html=self.html,\n            js_api=final_api,\n            width=self.width,\n            height=self.height,\n            resizable=self.resizable,\n            fullscreen=self.fullscreen,\n            min_size=self.min_size,\n            hidden=self.hidden,\n            frameless=self.frameless,\n            easy_drag=self.easy_drag,\n        )\n\n        # Bind events\n        if self.on_loaded: self._window.events.loaded += self.on_loaded\n        if self.on_closing: self._window.events.closing += self.on_closing\n        if self.on_closed: self._window.events.closed += self.on_closed\n        if self.on_shown: self._window.events.shown += self.on_shown\n        if self.on_minimized: self._window.events.minimized += self.on_minimized\n        if self.on_maximized: self._window.events.maximized += self.on_maximized\n        if self.on_restored: self._window.events.restored += self.on_restored\n        if self.on_resized: self._window.events.resized += self.on_resized\n        if self.on_moved: self._window.events.moved += self.on_moved\n\n        # Inject initial state if available\n        if hasattr(self, '_app_ref') and self._app_ref and hasattr(self._app_ref, 'state'):\n            # We need to wait for the window to be ready to receive events, \n            # but pywebview doesn't have a perfect \"ready for JS\" event that guarantees listeners are set.\n            # We can expose a method 'pytron_init' that the client calls?\n            # Or just try to emit after a short delay?\n            # For now, let's rely on the client asking for state or just pushing updates.\n            pass\n</code></pre>"},{"location":"api/#pytron.window.Window.emit","title":"<code>emit(event, data=None)</code>","text":"<p>Emit an event to the JavaScript frontend.</p> Source code in <code>pytron\\window.py</code> <pre><code>def emit(self, event, data=None):\n    \"\"\"\n    Emit an event to the JavaScript frontend.\n    \"\"\"\n    if self._window:\n        # We use a safe serialization\n        try:\n            # Serialize the payload using our encoder\n            payload = json.dumps(data, cls=PytronJSONEncoder)\n            self._window.evaluate_js(f\"window.__pytron_dispatch('{event}', {payload})\")\n            # Serialize the call arguments (event name and payload string)\n        except Exception as e:\n            print(f\"[Pytron] Failed to emit event '{event}': {e}\")\n</code></pre>"},{"location":"api/#pytron.window.Window.expose","title":"<code>expose(func=None, name=None)</code>","text":"<p>Expose a Python function to JavaScript. Can be used as a decorator. @window.expose def my_func(): ...</p> Source code in <code>pytron\\window.py</code> <pre><code>def expose(self, func=None, name=None):\n    \"\"\"\n    Expose a Python function to JavaScript. Can be used as a decorator.\n    @window.expose\n    def my_func(): ...\n    \"\"\"\n    if self._window:\n         raise RuntimeError(\"Cannot expose functions after window creation. Call expose() before app.run() or window.create().\")\n\n    # Handle decorator usage: @window.expose or @window.expose(name=\"foo\")\n    if func is None:\n        def decorator(f):\n            self.expose(f, name=name)\n            return f\n        return decorator\n\n    if name is None:\n        name = func.__name__\n    self._exposed_functions[name] = func\n    return func\n</code></pre>"},{"location":"api/#pytron.window.Window.shortcut","title":"<code>shortcut(key_combo, func=None)</code>","text":"<p>Register a keyboard shortcut for this window. Example: @window.shortcut('Ctrl+S')</p> Source code in <code>pytron\\window.py</code> <pre><code>def shortcut(self, key_combo, func=None):\n    \"\"\"\n    Register a keyboard shortcut for this window.\n    Example: @window.shortcut('Ctrl+S')\n    \"\"\"\n    if func is None:\n        def decorator(f):\n            self.shortcut(key_combo, f)\n            return f\n        return decorator\n    self.shortcuts[key_combo] = func\n    return func\n</code></pre>"},{"location":"api/#state","title":"State","text":""},{"location":"api/#pytron.state.ReactiveState","title":"<code>pytron.state.ReactiveState</code>","text":"<p>A magic object that syncs its attributes to the frontend automatically.</p> Source code in <code>pytron\\state.py</code> <pre><code>class ReactiveState:\n    \"\"\"\n    A magic object that syncs its attributes to the frontend automatically.\n    \"\"\"\n    def __init__(self, app):\n        # Use super().__setattr__ to avoid triggering our own hook for internal vars\n        super().__setattr__('_app', app)\n        super().__setattr__('_data', {})\n        # Re-entrant lock to allow nested access from same thread\n        super().__setattr__('_lock', threading.RLock())\n\n    def __setattr__(self, key, value):\n        # Store the value in a thread-safe manner\n        lock = getattr(self, '_lock', None)\n        if lock is not None:\n            with lock:\n                self._data[key] = value\n        else:\n            self._data[key] = value\n\n        # Broadcast to all windows outside of the lock to avoid potential deadlocks\n        app_ref = getattr(self, '_app', None)\n        if app_ref:\n            # Iterate over a snapshot of windows to avoid issues if list is mutated\n            for window in list(app_ref.windows):\n                try:\n                    window.emit('pytron:state-update', {'key': key, 'value': value})\n                except Exception as e:\n                    print(f\"[Pytron] Error emitting state update for key '{key}': {e}\")\n\n    def __getattr__(self, key):\n        lock = getattr(self, '_lock', None)\n        if lock is not None:\n            with lock:\n                return self._data.get(key)\n        return self._data.get(key)\n\n    def to_dict(self):\n        lock = getattr(self, '_lock', None)\n        if lock is not None:\n            with lock:\n                return dict(self._data)\n        return dict(self._data)\n\n    def update(self, mapping: dict):\n        \"\"\"\n        Atomically update multiple keys and emit updates for each key.\n        Use this when you want to set multiple state values from another thread\n        without causing intermediate inconsistent states.\n        \"\"\"\n        if not isinstance(mapping, dict):\n            raise TypeError('mapping must be a dict')\n\n        lock = getattr(self, '_lock', None)\n        if lock is not None:\n            with lock:\n                self._data.update(mapping)\n        else:\n            self._data.update(mapping)\n\n        app_ref = getattr(self, '_app', None)\n        if app_ref:\n            for key, value in mapping.items():\n                for window in list(app_ref.windows):\n                    try:\n                        window.emit('pytron:state-update', {'key': key, 'value': value})\n                    except Exception as e:\n                        print(f\"[Pytron] Error emitting state update for key '{key}': {e}\")\n</code></pre>"},{"location":"api/#pytron.state.ReactiveState.update","title":"<code>update(mapping)</code>","text":"<p>Atomically update multiple keys and emit updates for each key. Use this when you want to set multiple state values from another thread without causing intermediate inconsistent states.</p> Source code in <code>pytron\\state.py</code> <pre><code>def update(self, mapping: dict):\n    \"\"\"\n    Atomically update multiple keys and emit updates for each key.\n    Use this when you want to set multiple state values from another thread\n    without causing intermediate inconsistent states.\n    \"\"\"\n    if not isinstance(mapping, dict):\n        raise TypeError('mapping must be a dict')\n\n    lock = getattr(self, '_lock', None)\n    if lock is not None:\n        with lock:\n            self._data.update(mapping)\n    else:\n        self._data.update(mapping)\n\n    app_ref = getattr(self, '_app', None)\n    if app_ref:\n        for key, value in mapping.items():\n            for window in list(app_ref.windows):\n                try:\n                    window.emit('pytron:state-update', {'key': key, 'value': value})\n                except Exception as e:\n                    print(f\"[Pytron] Error emitting state update for key '{key}': {e}\")\n</code></pre>"},{"location":"api/#serializer","title":"Serializer","text":""},{"location":"api/#pytron.serializer.PytronJSONEncoder","title":"<code>pytron.serializer.PytronJSONEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> Source code in <code>pytron\\serializer.py</code> <pre><code>class PytronJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if pydantic and isinstance(obj, pydantic.BaseModel):\n            try:\n                return obj.model_dump()\n            except AttributeError:\n                return obj.dict()\n        if Image and isinstance(obj, Image.Image):\n            buffered = io.BytesIO()\n            obj.save(buffered, format=\"PNG\")\n            img_str = base64.b64encode(buffered.getvalue()).decode(\"utf-8\")\n            return f\"data:image/png;base64,{img_str}\"\n        if isinstance(obj, bytes):\n            return base64.b64encode(obj).decode('utf-8')\n        if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):\n            return obj.isoformat()\n        if isinstance(obj, uuid.UUID):\n            return str(obj)\n        if isinstance(obj, decimal.Decimal):\n            return float(obj)\n        if isinstance(obj, pathlib.Path):\n            return str(obj)\n        if isinstance(obj, set):\n            return list(obj)\n        return super().default(obj)\n</code></pre>"}]}